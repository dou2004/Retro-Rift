<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroids Arcade</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', monospace;
            color: #0f0;
            text-align: center;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #starfield {
            position: absolute;
            width: 200%;
            height: 200%;
            background: transparent;
        }
        
        .star {
            position: absolute;
            background-color: #fff;
            border-radius: 50%;
        }
        
        #game-area {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }
        
        #spaceship {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 30px solid #0f0;
            transform-origin: center;
            z-index: 10;
        }
        
        #spaceship::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 15px solid #f00;
            top: 30px;
            left: -10px;
            transition: all 0.1s ease;
        }
        
        #spaceship.thrust::after {
            border-top: 25px solid #f90;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            left: -15px;
        }
        
        .asteroid {
            position: absolute;
            background-color: #888;
            border-radius: 50%;
            transform-origin: center;
        }
        
        .fragment {
            position: absolute;
            background-color: #aaa;
            border-radius: 30%;
            transform-origin: center;
        }
        
        .laser {
            position: absolute;
            width: 2px;
            height: 20px;
            background-color: #0ff;
            box-shadow: 0 0 5px #0ff;
            transform-origin: center bottom;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            text-align: left;
        }
        
        #score {
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        #lives {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .life {
            width: 20px;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 20px solid #0f0;
        }
        
        #cooldown-container {
            width: 100px;
            height: 10px;
            border: 1px solid #0f0;
            margin-bottom: 10px;
        }
        
        #cooldown-bar {
            height: 100%;
            width: 100%;
            background-color: #0f0;
            transition: width 0.1s linear;
        }
        
        #hyperspace-container {
            width: 100px;
            height: 10px;
            border: 1px solid #00f;
            margin-bottom: 10px;
        }
        
        #hyperspace-bar {
            height: 100%;
            width: 0%;
            background-color: #00f;
        }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 2px solid #0f0;
            z-index: 200;
            display: none;
        }
        
        #restart-btn {
            background-color: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px 20px;
            margin-top: 20px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        
        #restart-btn:hover {
            background-color: #0f0;
            color: #000;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="starfield"></div>
        <div id="game-area">
            <div id="spaceship"></div>
        </div>
        <div id="ui">
            <div id="score">SCORE: 0</div>
            <div id="lives"></div>
            <div>LASER:</div>
            <div id="cooldown-container">
                <div id="cooldown-bar"></div>
            </div>
            <div>HYPERSPACE:</div>
            <div id="hyperspace-container">
                <div id="hyperspace-bar"></div>
            </div>
        </div>
        <div id="game-over">
            <h1>GAME OVER</h1>
            <div id="final-score">SCORE: 0</div>
            <button id="restart-btn">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        // Game constants
        const SHIP_SIZE = 30;
        const SHIP_SPEED = 5;
        const ROTATION_SPEED = 5;
        const FRICTION = 0.98;
        const LASER_COOLDOWN = 500;
        const HYPERSPACE_COOLDOWN = 5000;
        const STAR_COUNT = 200;
        const STAR_LAYERS = 3;
        const INITIAL_ASTEROID_COUNT = 3;
        const ASTEROID_SPAWN_RATE = 3000;
        const ASTEROID_SPAWN_DECREASE = 0.95;
        const MIN_ASTEROID_SPAWN_RATE = 1000;
        const FRAGMENT_COUNT = 3;
        
        // Game state
        let score = 0;
        let lives = 3;
        let gameOver = false;
        let asteroids = [];
        let fragments = [];
        let lasers = [];
        let stars = [];
        let lastAsteroidSpawn = 0;
        let asteroidSpawnRate = ASTEROID_SPAWN_RATE;
        let lastLaserTime = 0;
        let lastHyperspaceTime = 0;
        let keys = {};
        let shipState = {
            x: window.innerWidth / 2,
            y: window.innerHeight / 2,
            rotation: 0,
            velocityX: 0,
            velocityY: 0,
            thrusting: false
        };
        
        // DOM elements
        const gameArea = document.getElementById('game-area');
        const spaceship = document.getElementById('spaceship');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const cooldownBar = document.getElementById('cooldown-bar');
        const hyperspaceBar = document.getElementById('hyperspace-bar');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreDisplay = document.getElementById('final-score');
        const restartBtn = document.getElementById('restart-btn');
        const starfield = document.getElementById('starfield');
        
        // Initialize game
        function init() {
            createStars();
            createInitialAsteroids();
            updateLivesDisplay();
            
            // Set up event listeners
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            restartBtn.addEventListener('click', restartGame);
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }
        
        // Create starfield background
        function createStars() {
            for (let layer = 0; layer < STAR_LAYERS; layer++) {
                for (let i = 0; i < STAR_COUNT; i++) {
                    const star = document.createElement('div');
                    star.className = 'star';
                    
                    const size = Math.random() * (layer + 1);
                    const opacity = 0.5 + (layer * 0.2);
                    const speed = 0.5 + (layer * 0.5);
                    
                    star.style.width = `${size}px`;
                    star.style.height = `${size}px`;
                    star.style.opacity = opacity;
                    star.style.left = `${Math.random() * 100}%`;
                    star.style.top = `${Math.random() * 100}%`;
                    
                    starfield.appendChild(star);
                    stars.push({
                        element: star,
                        speed: speed,
                        x: parseFloat(star.style.left),
                        y: parseFloat(star.style.top)
                    });
                }
            }
        }
        
        // Create initial asteroids
        function createInitialAsteroids() {
            for (let i = 0; i < INITIAL_ASTEROID_COUNT; i++) {
                spawnAsteroid();
            }
        }
        
        // Spawn a new asteroid
        function spawnAsteroid() {
            const asteroid = document.createElement('div');
            asteroid.className = 'asteroid';
            
            const size = 30 + Math.random() * 30;
            let x, y;
            
            // Spawn from edges
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? -size : window.innerWidth + size;
                y = Math.random() * window.innerHeight;
            } else {
                x = Math.random() * window.innerWidth;
                y = Math.random() < 0.5 ? -size : window.innerHeight + size;
            }
            
            const speed = 1 + Math.random() * 2;
            const rotationSpeed = (Math.random() - 0.5) * 3;
            const angle = Math.atan2(
                shipState.y - y,
                shipState.x - x
            ) + (Math.random() - 0.5) * Math.PI/2;
            
            asteroid.style.width = `${size}px`;
            asteroid.style.height = `${size}px`;
            asteroid.style.left = `${x}px`;
            asteroid.style.top = `${y}px`;
            
            gameArea.appendChild(asteroid);
            
            asteroids.push({
                element: asteroid,
                x: x,
                y: y,
                size: size,
                speed: speed,
                velocityX: Math.cos(angle) * speed,
                velocityY: Math.sin(angle) * speed,
                rotation: 0,
                rotationSpeed: rotationSpeed
            });
        }
        
        // Create asteroid fragments
        function createFragments(x, y, size, count) {
            for (let i = 0; i < count; i++) {
                const fragment = document.createElement('div');
                fragment.className = 'fragment';
                
                const fragmentSize = size / 2;
                const speed = 2 + Math.random() * 3;
                const angle = Math.random() * Math.PI * 2;
                
                fragment.style.width = `${fragmentSize}px`;
                fragment.style.height = `${fragmentSize}px`;
                fragment.style.left = `${x}px`;
                fragment.style.top = `${y}px`;
                
                gameArea.appendChild(fragment);
                
                fragments.push({
                    element: fragment,
                    x: x,
                    y: y,
                    size: fragmentSize,
                    speed: speed,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    rotation: 0,
                    rotationSpeed: (Math.random() - 0.5) * 5
                });
            }
        }
        
        // Fire laser
        function fireLaser() {
            const now = Date.now();
            if (now - lastLaserTime < LASER_COOLDOWN) return;
            
            lastLaserTime = now;
            
            const laser = document.createElement('div');
            laser.className = 'laser';
            
            const tipX = shipState.x + Math.sin(shipState.rotation * Math.PI / 180) * SHIP_SIZE/2;
            const tipY = shipState.y - Math.cos(shipState.rotation * Math.PI / 180) * SHIP_SIZE/2;
            
            laser.style.left = `${tipX}px`;
            laser.style.top = `${tipY}px`;
            laser.style.transform = `rotate(${shipState.rotation}deg)`;
            
            gameArea.appendChild(laser);
            
            const speed = 10;
            const velocityX = Math.sin(shipState.rotation * Math.PI / 180) * speed;
            const velocityY = -Math.cos(shipState.rotation * Math.PI / 180) * speed;
            
            lasers.push({
                element: laser,
                x: tipX,
                y: tipY,
                velocityX: velocityX,
                velocityY: velocityY,
                lifetime: 1000
            });
            
            // Update cooldown bar
            cooldownBar.style.width = '0%';
            const cooldownInterval = setInterval(() => {
                const elapsed = Date.now() - lastLaserTime;
                const percent = Math.min(100, (elapsed / LASER_COOLDOWN) * 100);
                cooldownBar.style.width = `${percent}%`;
                
                if (percent >= 100) {
                    clearInterval(cooldownInterval);
                }
            }, 10);
        }
        
        // Activate hyperspace
        function activateHyperspace() {
            const now = Date.now();
            if (now - lastHyperspaceTime < HYPERSPACE_COOLDOWN) return;
            
            lastHyperspaceTime = now;
            
            // 10% chance of malfunction (teleport into asteroid)
            const malfunction = Math.random() < 0.1;
            
            if (malfunction) {
                // Find a random position inside an asteroid
                if (asteroids.length > 0) {
                    const asteroid = asteroids[Math.floor(Math.random() * asteroids.length)];
                    shipState.x = asteroid.x;
                    shipState.y = asteroid.y;
                    handleCollision();
                }
            } else {
                // Normal teleport to random position
                shipState.x = Math.random() * window.innerWidth;
                shipState.y = Math.random() * window.innerHeight;
            }
            
            // Reset velocity to prevent immediate drift
            shipState.velocityX = 0;
            shipState.velocityY = 0;
            
            // Update hyperspace bar
            hyperspaceBar.style.width = '0%';
            const cooldownInterval = setInterval(() => {
                const elapsed = Date.now() - lastHyperspaceTime;
                const percent = Math.min(100, (elapsed / HYPERSPACE_COOLDOWN) * 100);
                hyperspaceBar.style.width = `${percent}%`;
                
                if (percent >= 100) {
                    clearInterval(cooldownInterval);
                }
            }, 10);
        }
        
        // Handle collision
        function handleCollision() {
            lives--;
            updateLivesDisplay();
            
            if (lives <= 0) {
                gameOver = true;
                gameOverScreen.style.display = 'block';
                finalScoreDisplay.textContent = `SCORE: ${score}`;
            }
        }
        
        // Update lives display
        function updateLivesDisplay() {
            livesDisplay.innerHTML = '';
            for (let i = 0; i < lives; i++) {
                const life = document.createElement('div');
                life.className = 'life';
                livesDisplay.appendChild(life);
            }
        }
        
        // Restart game
        function restartGame() {
            // Clear all game elements
            asteroids.forEach(asteroid => asteroid.element.remove());
            fragments.forEach(fragment => fragment.element.remove());
            lasers.forEach(laser => laser.element.remove());
            
            // Reset game state
            score = 0;
            lives = 3;
            gameOver = false;
            asteroids = [];
            fragments = [];
            lasers = [];
            lastAsteroidSpawn = Date.now();
            asteroidSpawnRate = ASTEROID_SPAWN_RATE;
            lastLaserTime = 0;
            lastHyperspaceTime = 0;
            
            // Reset ship
            shipState.x = window.innerWidth / 2;
            shipState.y = window.innerHeight / 2;
            shipState.rotation = 0;
            shipState.velocityX = 0;
            shipState.velocityY = 0;
            shipState.thrusting = false;
            
            // Update UI
            scoreDisplay.textContent = `SCORE: ${score}`;
            updateLivesDisplay();
            cooldownBar.style.width = '100%';
            hyperspaceBar.style.width = '0%';
            gameOverScreen.style.display = 'none';
            
            // Create new asteroids
            createInitialAsteroids();
        }
        
        // Handle keyboard input
        function handleKeyDown(e) {
            keys[e.key] = true;
            
            if (e.key === ' ') {
                fireLaser();
                e.preventDefault();
            } else if (e.key === 'h') {
                activateHyperspace();
                e.preventDefault();
            }
        }
        
        function handleKeyUp(e) {
            keys[e.key] = false;
        }
        
        // Main game loop
        function gameLoop(timestamp) {
            if (gameOver) return;
            
            updateShip();
            updateStars();
            updateAsteroids();
            updateFragments();
            updateLasers();
            checkCollisions();
            spawnAsteroidsOverTime();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Update ship position and rotation
        function updateShip() {
            // Rotation
            if (keys['ArrowLeft']) {
                shipState.rotation -= ROTATION_SPEED;
            }
            if (keys['ArrowRight']) {
                shipState.rotation += ROTATION_SPEED;
            }
            
            // Thrust
            if (keys['ArrowUp']) {
                shipState.velocityX += Math.sin(shipState.rotation * Math.PI / 180) * 0.1;
                shipState.velocityY -= Math.cos(shipState.rotation * Math.PI / 180) * 0.1;
                shipState.thrusting = true;
                spaceship.classList.add('thrust');
            } else {
                shipState.thrusting = false;
                spaceship.classList.remove('thrust');
            }
            
            // Apply friction
            shipState.velocityX *= FRICTION;
            shipState.velocityY *= FRICTION;
            
            // Update position
            shipState.x += shipState.velocityX;
            shipState.y += shipState.velocityY;
            
            // Wrap around screen edges
            if (shipState.x < -SHIP_SIZE) shipState.x = window.innerWidth + SHIP_SIZE;
            if (shipState.x > window.innerWidth + SHIP_SIZE) shipState.x = -SHIP_SIZE;
            if (shipState.y < -SHIP_SIZE) shipState.y = window.innerHeight + SHIP_SIZE;
            if (shipState.y > window.innerHeight + SHIP_SIZE) shipState.y = -SHIP_SIZE;
            
            // Update DOM
            spaceship.style.left = `${shipState.x - SHIP_SIZE/2}px`;
            spaceship.style.top = `${shipState.y - SHIP_SIZE/2}px`;
            spaceship.style.transform = `rotate(${shipState.rotation}deg)`;
        }
        
        // Update starfield for parallax effect
        function updateStars() {
            stars.forEach(star => {
                // Move stars based on ship velocity and their layer speed
                star.x -= shipState.velocityX * 0.1 * star.speed;
                star.y -= shipState.velocityY * 0.1 * star.speed;
                
                // Wrap stars around when they go off screen
                if (star.x < -5) star.x = 105;
                if (star.x > 105) star.x = -5;
                if (star.y < -5) star.y = 105;
                if (star.y > 105) star.y = -5;
                
                star.element.style.left = `${star.x}%`;
                star.element.style.top = `${star.y}%`;
            });
        }
        
        // Update asteroids
        function updateAsteroids() {
            asteroids.forEach((asteroid, index) => {
                // Update position
                asteroid.x += asteroid.velocityX;
                asteroid.y += asteroid.velocityY;
                
                // Update rotation
                asteroid.rotation += asteroid.rotationSpeed;
                
                // Wrap around screen edges
                if (asteroid.x < -asteroid.size) asteroid.x = window.innerWidth + asteroid.size;
                if (asteroid.x > window.innerWidth + asteroid.size) asteroid.x = -asteroid.size;
                if (asteroid.y < -asteroid.size) asteroid.y = window.innerHeight + asteroid.size;
                if (asteroid.y > window.innerHeight + asteroid.size) asteroid.y = -asteroid.size;
                
                // Update DOM
                asteroid.element.style.left = `${asteroid.x - asteroid.size/2}px`;
                asteroid.element.style.top = `${asteroid.y - asteroid.size/2}px`;
                asteroid.element.style.transform = `rotate(${asteroid.rotation}deg)`;
            });
        }
        
        // Update fragments
        function updateFragments() {
            fragments.forEach((fragment, index) => {
                // Update position
                fragment.x += fragment.velocityX;
                fragment.y += fragment.velocityY;
                
                // Update rotation
                fragment.rotation += fragment.rotationSpeed;
                
                // Wrap around screen edges
                if (fragment.x < -fragment.size) fragment.x = window.innerWidth + fragment.size;
                if (fragment.x > window.innerWidth + fragment.size) fragment.x = -fragment.size;
                if (fragment.y < -fragment.size) fragment.y = window.innerHeight + fragment.size;
                if (fragment.y > window.innerHeight + fragment.size) fragment.y = -fragment.size;
                
                // Update DOM
                fragment.element.style.left = `${fragment.x - fragment.size/2}px`;
                fragment.element.style.top = `${fragment.y - fragment.size/2}px`;
                fragment.element.style.transform = `rotate(${fragment.rotation}deg)`;
            });
        }
        
        // Update lasers
        function updateLasers() {
            const now = Date.now();
            
            lasers.forEach((laser, index) => {
                // Update position
                laser.x += laser.velocityX;
                laser.y += laser.velocityY;
                
                // Update DOM
                laser.element.style.left = `${laser.x}px`;
                laser.element.style.top = `${laser.y}px`;
                
                // Check lifetime
                if (now - lastLaserTime > laser.lifetime) {
                    laser.element.remove();
                    lasers.splice(index, 1);
                }
            });
        }
        
        // Check for collisions
        function checkCollisions() {
            // Check laser-asteroid collisions
            lasers.forEach((laser, laserIndex) => {
                asteroids.forEach((asteroid, asteroidIndex) => {
                    const dx = laser.x - asteroid.x;
                    const dy = laser.y - asteroid.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < asteroid.size / 2) {
                        // Collision detected
                        laser.element.remove();
                        lasers.splice(laserIndex, 1);
                        
                        // Score points based on asteroid size
                        score += Math.floor(asteroid.size);
                        scoreDisplay.textContent = `SCORE: ${score}`;
                        
                        // Create fragments
                        createFragments(asteroid.x, asteroid.y, asteroid.size, FRAGMENT_COUNT);
                        
                        // Remove asteroid
                        asteroid.element.remove();
                        asteroids.splice(asteroidIndex, 1);
                        
                        return;
                    }
                });
            });
            
            // Check laser-fragment collisions
            lasers.forEach((laser, laserIndex) => {
                fragments.forEach((fragment, fragmentIndex) => {
                    const dx = laser.x - fragment.x;
                    const dy = laser.y - fragment.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < fragment.size / 2) {
                        // Collision detected
                        laser.element.remove();
                        lasers.splice(laserIndex, 1);
                        
                        // Score points for fragments
                        score += 5;
                        scoreDisplay.textContent = `SCORE: ${score}`;
                        
                        // Remove fragment
                        fragment.element.remove();
                        fragments.splice(fragmentIndex, 1);
                        
                        return;
                    }
                });
            });
            
            // Check ship-asteroid collisions
            asteroids.forEach(asteroid => {
                const dx = shipState.x - asteroid.x;
                const dy = shipState.y - asteroid.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < (SHIP_SIZE/2 + asteroid.size/2)) {
                    handleCollision();
                }
            });
            
            // Check ship-fragment collisions
            fragments.forEach(fragment => {
                const dx = shipState.x - fragment.x;
                const dy = shipState.y - fragment.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < (SHIP_SIZE/2 + fragment.size/2)) {
                    handleCollision();
                }
            });
        }
        
        // Spawn asteroids over time with increasing difficulty
        function spawnAsteroidsOverTime() {
            const now = Date.now();
            if (now - lastAsteroidSpawn > asteroidSpawnRate) {
                spawnAsteroid();
                lastAsteroidSpawn = now;
                
                // Increase spawn rate (up to a minimum)
                asteroidSpawnRate = Math.max(
                    MIN_ASTEROID_SPAWN_RATE,
                    asteroidSpawnRate * ASTEROID_SPAWN_DECREASE
                );
            }
        }
        
        // Start the game
        init();
    </script>
</body>
</html>